---
title:  "Setting up a Jekyll site with a Streaming Service Worker"
image: /assets/dist/images/streaming-service-workers/streaming-service-workers.jpg
tags:
  - Streams
  - Service Worker
  - JavaScript
---

For my first foray into streams I decided to try and hook up this site, a static site generated by [Jekyll](https://jekyllrb.com/), with a streaming service worker.

## Wait, what's a stream?

According to Wikipedia, a stream is a ["sequence of data elements made available over time"](https://en.wikipedia.org/wiki/Stream_(computing)). They allow you to read and write asynchronous chunks of data, as and when they become available. There exist 3 different types of streams:

- **Readable Streams:** Represent a source of data, from which you can read. In other words, data comes out of a readable stream. Concretely, a readable stream is an instance of the ReadableStream class.
- **Writable Streams:** Represent a destination for data, into which you can write. In other words, data goes in to a writable stream. Concretely, a writable stream is an instance of the WritableStream class.
- **Transform Streams:** Consist of a pair of streams: a writable stream, and a readable stream. In a manner specific to the transform stream in question, writes to the writable side result in new data being made available for reading from the readable side. Concretely, any object with a writable property and a readable property can serve as a transform stream.

*Definitions taken from the [whatwg streams spec](https://streams.spec.whatwg.org)*

**N.B: Transform Streams have not been fully developed yet and as such are not available  without a polyfill, more on this later..**

## Use case

That's great and all, but what would be an actual use case for using a stream? Let's say we want to fetch the content for a given page, perhaps the content for a particular blog post? Traditionally we would generate the static markup for the page, including all extra elements like headers, footer etc. We would make a request for the page, wait for it to be retrieved, process the HTML and render it onto the page. This is generally a bad experience for the user as they're provided with a blank page until everything is loaded and processed, which could take considerable time, whereupon all the content flashes in.

An alternative method which is commonly employed is initally loading an ['app shell'](https://developers.google.com/web/fundamentals/architecture/app-shell) while asynchronously loading the main page content. An app shell is the minimal HTML, CSS and JavaScript required to power the user interface, i.e. the header and footer for a page and perhaps some placeholder content signifying that the main content is loading (think [Facebook's placeholder content](https://cloudcannon.com/deconstructions/2014/11/15/facebook-content-placeholder-deconstruction.html) while posts etc. are loading).

Streams provide a newer alternative to the traditional App Shell model, one in which the user gets access to meaningful content faster when navigating to a page. Streaming a response employs similar tactics to loading a page via the App Shell model. Much like App Shell, a streamed response takes advantage of caching initial chunks of HTML in order to display them instantly, even while offline. These cached chunks of HTML usually include the `<head>`, header and footer elements (i.e. those that do not change their content across multiple pages\*). These cached chunks are sent to user, providing an immediate response (rather than a blank page while everything loads as in a HTML page served traditionally). The difference comes when loading and displaying the dynamic page content. In the app shell model, this content is typically fetched, processed and then rendered onto the page all in one go. This can often leave the user with a large blank space while all the content is being downloaded, parsed and processed (it is not uncommon to leave placeholder content, as mentioned earlier, and/or a loading indicator while this is going on). However, with streaming, we get to render chunks of the content as soon as it is fetched and process, while the rest of the content is still fetching or processing. This allows us to display content on the page *as soon* as it is available, without having to wait for the rest of the content to be ready. Technically, we're even able to render the whole content quicker because the processing and rendering can happen in parallel with the fetching, instead of serially! You can see how this links to the definition of a transform stream as detailed earlier, first we *read* from the network, *transform* it to HTML data, then *write/render* it to the screen.

Jake Archibald has a fantastic [blog post](https://jakearchibald.com/2016/streams-ftw/) on the benefits of streams, with some great GIFS and diagrams to help explain the streaming process (that I could only dream of being able to replicate).

Recently, the use of streams has been exposed to developers, allowing for custom streamed responses to page fetch requests within the service worker. Streams are not new to browsers though, elements such as images and videos are automatically streamed (think about when you see an image load in by 'chunks' at a time when on a poor connection).

\*we will discuss changing the page title later.

## Streams and Jekyll sites

It's clear to see how streams could help with the loading of posts within a typical blog-style Jekyll site.